#ifndef ARRAY_H#define ARRAY_H/** *  Array.h *  Author:     Joe Liu *  Created:    January 13, 2016 * *  A simple array class with basic utilities and functions.  */#include <algorithm>#include <iostream>// Array class definitiontemplate <typename T>class Array {  private:    int array_capacity;    T *internal_array;    int array_size;  public:    // Member function declarations    Array(int = 10);    ~Array();    // Accessors    T operator[](int) const;    int size() const;    int capacity() const;    bool empty() const;    bool full() const;    T sum() const;    double average() const;    double variance() const;    double std_dev() const;    T get( int ) const;    // Mutators    bool append( T const & );    void clear();    // Friends    friend std::ostream &operator<< ( std::ostream &, Array<T> const & );};template <typename T>Array<T>::Array( int n ):array_capacity( std::max(1, n) ),internal_array( new T[array_capacity] ),array_size( 0 ) {    // empty}template <typename T>Array<T>::~Array() {  delete[] internal_array;}template <typename T>T Array<T>::operator[](int n) const {    return internal_array[n];}std::ostream &operator <<( std::ostream& out, Array<int> const & para ) {  if ( para.empty() ) {    out << "-";  } else {    out << para.internal_array[0];  }  for ( int i = 1; i < para.size(); ++i ) {    out << " " << para.internal_array[i];  }  for ( int i = para.size(); i < para.capacity(); ++i ) {    out << " -";  }  return out;}template <typename T>T Array<T>::get( int idx ) const {  return internal_array[idx];}template <typename T>int Array<T>::size() const {  return array_size;}template <typename T>int Array<T>::capacity() const {  return array_capacity;}template <typename T>bool Array<T>::empty() const {  return array_size == 0;}template <typename T>bool Array<T>::full() const {  return array_size == array_capacity;}template <typename T>T Array<T>::sum() const {  if ( empty() ) {    throw underflow();  }  int sum = 0;  for (int idx = 0; idx < array_size; ++idx) {    sum += internal_array[idx];  }  return sum;}template <typename T>bool Array<T>::append( T const &obj ) {  if ( full() ) {    std::cout << "Array full, " << obj << " not appended" << std::endl;    return false;  }  internal_array[array_size] = obj;  ++array_size;  return true;}template <typename T>void Array<T>::clear() {  array_size = 0;}#endif